1. a -- GDT,LDT描述符及其属性，cr0开启保护模式
2. b -- 如何从保护模式回到实模式，高速缓冲器，从16位的代码跳转而不是32位。在保护模式下仍然可以使用实模式，基址为20位，段界限为0xffff，无法直接修改高速缓冲器，因此通过向段寄存器写入新的符合实模式规定的选择子进行修改，然后跳转。
   1. 流程为先更新除了cs外的所有段寄存器，然后进入实模式，然后跳转到16位代码处 `jmp 0: LABEL_REAL_ENTRY`
   2. 上面的0在之前已经被修改 `mov [LABEL_GO_BACK_TO_REAL + 3], ax` （ax is cs）
3. c -- LDT, 在GDT中建立每个LDT表的descriptor，然后在相应的LDT表中建立code data段。LDT和GDT的选择子通过TI位进行区分
4. d -- 调用门:段选择子，偏移(这两个确定了相应的代码段的位置)，param count参数的数量。实际上就是一个长调用，但是有相应的权限检查
5. e -- TSS 记载了不同的权限对应的ss和esp的信息，可以准确切换堆栈
6. 6 -- 分页模式cr0开启，cr3指向页表的基地址。stosd\w\b 与 STD\CLD结合使用初始化页表
7. g -- 通过改变cr3来改变页表，实现同一个线性地址对应不同的物理地址，执行出不同的结果
8. i -- 中断与异常， 建立中断向量表，然后表的基址存入IDTR。同时开启8259A时钟中断，然后修改相应表中项的处理函数

关于保护模式
1. 描述符的属性以及界限保护了每一个段的访问
2. CPL，DPL，RPL结合的检测实现了不同段之间的访问
3. 分页机制中的属性的保护，分页机制中线性空间的隔离

使用selector类似的相对于段的偏移来定位数据或代码在一个段内的位置

特权级变换，中断门的特权级变换和调用门类似。

中断门会清楚cflag的IF位，从而不允许中断重入，但是陷入门不会。